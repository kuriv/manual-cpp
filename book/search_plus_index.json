{"./":{"url":"./","title":"C++","keywords":"","body":"C++ C++ 是一种计算机高级程序设计语言，由 C 语言扩展升级而产生。 "},"docs/新启程.html":{"url":"docs/新启程.html","title":"新启程","keywords":"","body":"新启程 以下是第一个 C++ 语言程序，也是新启程的开始。 #include using namespace std; int main(int argc, char const *argv[]) { cout 由于 C 和 C++ 两种编程语言有许多相似之处，在此仅展示 C++ 重要功能特性，可以 前往此处 了解 C 语言的更多信息。 "},"docs/变量声明.html":{"url":"docs/变量声明.html","title":"变量声明","keywords":"","body":"变量声明 C++ 允许使用另一种语法来声明和初始化变量。 #include using namespace std; int main(int argc, char const *argv[]) { int input1(233); double input2(6.66); cout "},"docs/输入输出.html":{"url":"docs/输入输出.html","title":"输入输出","keywords":"","body":"输入输出 标准输入输出 格式化输出 "},"docs/输入输出/标准输入输出.html":{"url":"docs/输入输出/标准输入输出.html","title":"标准输入输出","keywords":"","body":"标准输入输出 执行下面的代码，从键盘读取输入并输出。 #include using namespace std; int main(int argc, char const *argv[]) { int input; cin >> input; cout 也可以用一条语句读取多个输入。 #include using namespace std; int main(int argc, char const *argv[]) { int input1, input2, input3; cin >> input1 >> input2 >> input3; cout "},"docs/输入输出/格式化输出.html":{"url":"docs/输入输出/格式化输出.html","title":"格式化输出","keywords":"","body":"格式化输出 执行下面的代码，给一个浮点数指定总的显示位数。 #include #include using namespace std; int main(int argc, char const *argv[]) { double d = 12.3456; cout 执行下面的代码，将数字强制显示为非科学计数法的形式。 #include using namespace std; int main(int argc, char const *argv[]) { cout 可以结合以上操作来强制显示小数点后的位数。 #include #include using namespace std; int main(int argc, char const *argv[]) { double d1 = 345.4567; double d2 = 78676.887234; cout 也可以使用下面的方法来强制浮点数显示小数点。 #include #include using namespace std; int main(int argc, char const *argv[]) { cout 执行下面的代码，指定输出的最小列数。 #include #include using namespace std; int main(int argc, char const *argv[]) { cout 执行下面的代码，指定输出的最小列数，并分别设置输出为右对齐和左对齐。 #include #include using namespace std; int main(int argc, char const *argv[]) { cout "},"docs/变量类型.html":{"url":"docs/变量类型.html","title":"变量类型","keywords":"","body":"变量类型 类型转换 布尔类型 引用类型 字符串类型 "},"docs/变量类型/类型转换.html":{"url":"docs/变量类型/类型转换.html","title":"类型转换","keywords":"","body":"类型转换 C++ 允许通过转换运算符把数据由一种数据类型显式转换为另一种数据类型。 #include using namespace std; int main(int argc, char const *argv[]) { cout (6.66) (1) / 2 "},"docs/变量类型/布尔类型.html":{"url":"docs/变量类型/布尔类型.html","title":"布尔类型","keywords":"","body":"布尔类型 保存布尔值的变量称为布尔变量。 #include using namespace std; int main(int argc, char const *argv[]) { bool flag = true; cout "},"docs/变量类型/引用类型.html":{"url":"docs/变量类型/引用类型.html","title":"引用类型","keywords":"","body":"引用类型 可以通过引用变量来访问和修改存储在变量中的原数据。 #include using namespace std; int main(int argc, char const *argv[]) { int num = 1; int &r = num; cout "},"docs/变量类型/字符串类型.html":{"url":"docs/变量类型/字符串类型.html","title":"字符串类型","keywords":"","body":"字符串类型 C++ 提供了一种新的对象类型，用于保存字符串。 #include using namespace std; int main(int argc, char const *argv[]) { string str1 = \"Hello World!\"; cout "},"docs/字符串操作.html":{"url":"docs/字符串操作.html","title":"字符串操作","keywords":"","body":"字符串操作 字符串赋值 字符串连接 字符串追加 字符串比较 字符串搜索 获取子串 字符串插入与替换 字符串分割 其他操作 "},"docs/字符串操作/字符串赋值.html":{"url":"docs/字符串操作/字符串赋值.html","title":"字符串赋值","keywords":"","body":"字符串赋值 C++ 提供了几个重载函数，用于赋予字符串新的内容。 #include using namespace std; int main(int argc, char const *argv[]) { string str1(\"Hello\"); str1.assign(\"Welcome\"); cout "},"docs/字符串操作/字符串连接.html":{"url":"docs/字符串操作/字符串连接.html","title":"字符串连接","keywords":"","body":"字符串连接 执行下面的代码，连接两个字符串。 #include using namespace std; int main(int argc, char const *argv[]) { string str1(\"Hello\"); string str2(\" World!\"); cout "},"docs/字符串操作/字符串追加.html":{"url":"docs/字符串操作/字符串追加.html","title":"字符串追加","keywords":"","body":"字符串追加 C++ 提供了几个重载函数来向一个字符串追加新的内容。 #include using namespace std; int main(int argc, char const *argv[]) { string str1(\"Hello\"); str1.append(\" World!\"); cout "},"docs/字符串操作/字符串比较.html":{"url":"docs/字符串操作/字符串比较.html","title":"字符串比较","keywords":"","body":"字符串比较 执行下面的代码，将字符串从左到右每一个字符对应比较。 #include using namespace std; int main(int argc, char const *argv[]) { string str1(\"ABC\"); string str2(\"ABE\"); cout str2) = str2) "},"docs/字符串操作/字符串搜索.html":{"url":"docs/字符串操作/字符串搜索.html","title":"字符串搜索","keywords":"","body":"字符串搜索 执行下面的代码，再字符串中搜索一个字符或一个子串。 #include using namespace std; int main(int argc, char const *argv[]) { string str(\"Hello World!\"); cout "},"docs/字符串操作/获取子串.html":{"url":"docs/字符串操作/获取子串.html","title":"获取子串","keywords":"","body":"获取子串 执行下面的代码，获取字符串的一个子串。 #include using namespace std; int main(int argc, char const *argv[]) { string str(\"Hello World!\"); cout "},"docs/字符串操作/字符串插入与替换.html":{"url":"docs/字符串操作/字符串插入与替换.html","title":"字符串插入与替换","keywords":"","body":"字符串插入与替换 执行下面的代码，在字符串中插入一个子串。 #include using namespace std; int main(int argc, char const *argv[]) { string str(\"Hello World!\"); str.insert(6, \"C \"); cout 执行下面的代码，从字符串中替换一个子串。 #include using namespace std; int main(int argc, char const *argv[]) { string str(\"Hello World!\"); str.replace(6, 5, \"C++\"); cout "},"docs/字符串操作/字符串分割.html":{"url":"docs/字符串操作/字符串分割.html","title":"字符串分割","keywords":"","body":"字符串分割 执行下面的代码，从字符串中抽取单词。 #include #include using namespace std; int main(int argc, char const *argv[]) { string str(\"Hello Welcome To C++ World!\"); stringstream ss(str); string word; while (!ss.eof()) { ss >> word; cout "},"docs/字符串操作/其他操作.html":{"url":"docs/字符串操作/其他操作.html","title":"其他操作","keywords":"","body":"其他操作 执行下面的代码，提取字符串中指定位置的字符。 #include using namespace std; int main(int argc, char const *argv[]) { string str(\"Hello World!\"); cout 执行下面的代码，删除字符串指定的部分。 #include using namespace std; int main(int argc, char const *argv[]) { string str(\"Hello World!\"); cout 执行下面的代码，清空字符串。 #include using namespace std; int main(int argc, char const *argv[]) { string str(\"Hello World!\"); str.clear(); cout 执行下面的代码，检测字符串是否为空。 #include using namespace std; int main(int argc, char const *argv[]) { string str(\"Hello World!\"); str.clear(); cout 执行下面的代码，获取字符串的长度。 #include using namespace std; int main(int argc, char const *argv[]) { string str(\"Hello World!\"); cout 执行下面的代码，获取字符串的存储空间。 #include using namespace std; int main(int argc, char const *argv[]) { string str(\"Hello World!\"); cout "},"docs/函数重载.html":{"url":"docs/函数重载.html","title":"函数重载","keywords":"","body":"函数重载 函数重载可以用同样的名字命名函数，只要函数的参数不同。 #include using namespace std; int max(int x, int y) { return x > y ? x : y; } double max(double x, double y) { return x > y ? x : y; } double max(double x, double y, double z) { return max(max(x, y), z); } int main(int argc, char const *argv[]) { cout "},"docs/函数模板.html":{"url":"docs/函数模板.html","title":"函数模板","keywords":"","body":"函数模板 C++ 允许定义具有通用类型的函数模板。 #include using namespace std; template T maxValue(T x, T y) { return x > y ? x : y; } int main(int argc, char const *argv[]) { cout 执行下面的代码，使参数按引用传递。 #include using namespace std; template T maxValue(const T &x, const T &y) { return x > y ? x : y; } int main(int argc, char const *argv[]) { cout "},"docs/面向对象.html":{"url":"docs/面向对象.html","title":"面向对象","keywords":"","body":"面向对象 声明类 定义与实现分离 数据域封装 友元函数 对象数组 静态成员 析构函数 模板类 向量类 继承 "},"docs/面向对象/声明类.html":{"url":"docs/面向对象/声明类.html","title":"声明类","keywords":"","body":"声明类 执行下面的代码，定义类的属性和方法，并通过类来创建对象。 #include using namespace std; class Point { public: double x; double y; Point() { this->x = 0; this->y = 0; } Point(double x, double y) { this->x = x; this->y = y; } }; int main(int argc, char const *argv[]) { Point p1; cout 执行下面的代码，通过创建匿名对象的方式来使用对象。 #include using namespace std; class Point { public: double x; double y; Point() { this->x = 0; this->y = 0; } Point(double x, double y) { this->x = x; this->y = y; } }; int main(int argc, char const *argv[]) { cout "},"docs/面向对象/定义与实现分离.html":{"url":"docs/面向对象/定义与实现分离.html","title":"定义与实现分离","keywords":"","body":"定义与实现分离 类定义列出所有数据域、构造函数原型和函数原型，类实现给出构造函数和成员函数的实现，两者可以置于两个分离的文件中。其中，类定义文件的扩展名为 .h ，代码如下。 class Point { public: double x; double y; Point(); Point(double, double); }; 类实现文件的扩展名为 .cpp ，代码如下。 #include \"Point.h\" Point::Point() { this->x = 0; this->y = 0; } Point::Point(double x, double y) { this->x = x; this->y = y; } 执行下面的代码，通过类来创建对象并使用。 #include #include \"Point.cpp\" using namespace std; int main(int argc, char const *argv[]) { Point p1; cout "},"docs/面向对象/数据域封装.html":{"url":"docs/面向对象/数据域封装.html","title":"数据域封装","keywords":"","body":"数据域封装 数据域私有可以保护数据，并且使类易于维护。 #include using namespace std; class Point { private: double x; double y; public: Point() { this->x = 0; this->y = 0; } Point(double x, double y) { this->x = x; this->y = y; } double getX() { return this->x; } double getY() { return this->y; } void setX(double x) { this->x = x; } void setY(double y) { this->y = y; } }; int main(int argc, char const *argv[]) { Point p1; cout "},"docs/面向对象/友元函数.html":{"url":"docs/面向对象/友元函数.html","title":"友元函数","keywords":"","body":"友元函数 可以通过定义友元类或友元函数，使其能够访问其他类中的私有成员。 #include using namespace std; class Point { private: double x; double y; public: Point() { this->x = 0; this->y = 0; } Point(double x, double y) { this->x = x; this->y = y; } double getX() { return this->x; } double getY() { return this->y; } void setX(double x) { this->x = x; } void setY(double y) { this->y = y; } friend class Rect; }; class Rect { public: static void print() { Point p; p.x = 100; p.y = 200; cout "},"docs/面向对象/对象数组.html":{"url":"docs/面向对象/对象数组.html","title":"对象数组","keywords":"","body":"对象数组 C++ 可以创建基本类型或字符串数组，同样可以创建对象的数组。 #include using namespace std; class Point { private: double x; double y; public: Point() { this->x = 0; this->y = 0; } Point(double x, double y) { this->x = x; this->y = y; } double getX() { return this->x; } double getY() { return this->y; } void setX(double x) { this->x = x; } void setY(double y) { this->y = y; } }; int main(int argc, char const *argv[]) { Point arr1[3]; cout "},"docs/面向对象/静态成员.html":{"url":"docs/面向对象/静态成员.html","title":"静态成员","keywords":"","body":"静态成员 静态变量和静态函数无需创建对象即可访问。 #include using namespace std; class Point { private: double x; double y; static double z; public: Point() { this->x = 0; this->y = 0; } Point(double x, double y) { this->x = x; this->y = y; } double getX() { return this->x; } double getY() { return this->y; } static double getZ() { return Point::z; } void setX(double x) { this->x = x; } void setY(double y) { this->y = y; } static void setZ(double z) { Point::z = z; } }; double Point::z = 0; int main(int argc, char const *argv[]) { cout "},"docs/面向对象/析构函数.html":{"url":"docs/面向对象/析构函数.html","title":"析构函数","keywords":"","body":"析构函数 当一个对象销毁时将自动调用该析构函数。 #include using namespace std; class Point { private: double x; double y; public: Point() { this->x = 0; this->y = 0; } Point(double x, double y) { this->x = x; this->y = y; } ~Point() { cout x; } double getY() { return this->y; } void setX(double x) { this->x = x; } void setY(double y) { this->y = y; } }; int main(int argc, char const *argv[]) { Point p1; Point p2(1.23, 4.56); return 0; } "},"docs/面向对象/模板类.html":{"url":"docs/面向对象/模板类.html","title":"模板类","keywords":"","body":"模板类 执行下面的代码，定义具有通用类型的类。 #include using namespace std; template class Point { private: T x; T y; public: Point() { this->x = 0; this->y = 0; } Point(T x, T y) { this->x = x; this->y = y; } T getX() { return this->x; } T getY() { return this->y; } void setX(T x) { this->x = x; } void setY(T y) { this->y = y; } }; int main(int argc, char const *argv[]) { Point p1; cout p2(100, 200); cout p3(1.23, 4.56); cout "},"docs/面向对象/向量类.html":{"url":"docs/面向对象/向量类.html","title":"向量类","keywords":"","body":"向量类 C++ 提供了向量类，它比数组更灵活，大小可以按需自动增长。 #include #include using namespace std; int main(int argc, char const *argv[]) { vector arr; for (int i = 0; i 执行下面的代码，删除向量最后一个元素。 #include #include using namespace std; int main(int argc, char const *argv[]) { vector arr; for (int i = 0; i 执行下面的代码，交换两个向量数据。 #include #include using namespace std; int main(int argc, char const *argv[]) { vector arr1, arr2; for (int i = 0; i = 0; i--) { arr2.push_back(i); } for (int i = 0; i 执行下面的代码，删除向量中所有元素。 #include #include using namespace std; int main(int argc, char const *argv[]) { vector arr; for (int i = 0; i 二维数组可以用向量的向量来表示。 #include #include using namespace std; int main(int argc, char const *argv[]) { vector> matrix(3); for (int i = 0; i (3); for (int j = 0; j "},"docs/面向对象/继承.html":{"url":"docs/面向对象/继承.html","title":"继承","keywords":"","body":"继承 C++ 继承允许声明一个基类，并随后将其扩展为派生类。 #include using namespace std; class Animal { public: void call() { cout 在基类中定义的函数能够在派生类中被重新定义。 #include using namespace std; class Animal { public: void call() { cout 公有成员可以被任意其他类所访问，私有成员只能在类内或通过友元函数和友元类访问，而保护成员只能在类内或派生类访问。 #include using namespace std; class Animal { protected: string name; public: Animal() { this->name = \"Anonymous\"; } }; class Cat : public Animal { public: void call() { cout name "},"docs/指针及内存.html":{"url":"docs/指针及内存.html","title":"指针及内存","keywords":"","body":"指针及内存 数组函数 内存分配 动态对象 "},"docs/指针及内存/数组函数.html":{"url":"docs/指针及内存/数组函数.html","title":"数组函数","keywords":"","body":"数组函数 执行下面的代码，返回指向数组中最小和最大元素的指针。 #include #include using namespace std; int main(int argc, char const *argv[]) { int arr[] = {4, 2, 3, 6, 5, 1}; int *min = min_element(arr, arr + 6); cout 执行下面的代码，对数组进行随机洗牌。 #include #include using namespace std; void print(int arr[], int n) { for (int i = 0; i 执行下面的代码，对数组进行排序。 #include #include using namespace std; void print(int arr[], int n) { for (int i = 0; i 执行下面的代码，在数组中查找某个元素。 #include #include using namespace std; int main(int argc, char const *argv[]) { int arr[] = {4, 2, 3, 6, 5, 1}; int *p = find(arr, arr + 6, 2); cout "},"docs/指针及内存/内存分配.html":{"url":"docs/指针及内存/内存分配.html","title":"内存分配","keywords":"","body":"内存分配 C++ 支持动态分配持久的内存空间。 #include using namespace std; int main(int argc, char const *argv[]) { int *p1 = new int(233); cout "},"docs/指针及内存/动态对象.html":{"url":"docs/指针及内存/动态对象.html","title":"动态对象","keywords":"","body":"动态对象 执行下面的代码，在堆中动态创建对象。 #include using namespace std; class Point { private: double x; double y; public: Point() { x = 0; y = 0; } Point(double x, double y) { this->x = x; this->y = y; } double getX() { return x; } double getY() { return y; } void setX(double x) { this->x = x; } void setY(double y) { this->y = y; } }; int main(int argc, char const *argv[]) { Point *p1 = new Point(); delete p1; Point *p2 = new Point; delete p2; Point *p3 = new Point(1.23, 4.56); cout getX() getY() "},"docs/文件输入输出.html":{"url":"docs/文件输入输出.html","title":"文件输入输出","keywords":"","body":"文件输入输出 执行下面的代码，打开指定文件并读取数据。 #include #include using namespace std; int main(int argc, char const *argv[]) { ifstream file; file.open(\"index.txt\"); if (file.fail()) { cout > x >> y >> z; cout 执行下面的代码，打开指定文件并写入数据。 #include #include using namespace std; int main(int argc, char const *argv[]) { ofstream file(\"index.txt\"); if (file.fail()) { cout 执行下面的代码，读入指定文件中所有数据。 #include #include using namespace std; int main(int argc, char const *argv[]) { ifstream file(\"index.txt\"); if (file.fail()) { cout > num; cout 执行下面的代码，对指定的文件进行输入和输出。 #include #include using namespace std; int main(int argc, char const *argv[]) { fstream file(\"index.txt\", ios::in); if (file.fail()) { cout > str; cout "},"docs/运算符重载.html":{"url":"docs/运算符重载.html","title":"运算符重载","keywords":"","body":"运算符重载 C++ 中大部分运算符都被定义为函数，用于执行一定的操作。 #include using namespace std; int main(int argc, char const *argv[]) { string str1(\"Hello!\"); string str2(\"Welcome!\"); cout 执行下面的代码，定义运算符函数。 #include using namespace std; class Point { private: double x; double y; public: Point() { this->x = 0; this->y = 0; } Point(double x, double y) { this->x = x; this->y = y; } double getX() { return this->x; } double getY() { return this->y; } void setX(double x) { this->x = x; } void setY(double y) { this->y = y; } Point operator+(const Point p) { return Point(this->x + p.x, this->y + p.y); } }; int main(int argc, char const *argv[]) { Point p1(100, 200); cout "},"docs/异常处理.html":{"url":"docs/异常处理.html","title":"异常处理","keywords":"","body":"异常处理 异常处理能够使程序处理一些特殊现象，并继续正确的执行。 #include using namespace std; int main(int argc, char const *argv[]) { double x, y; cin >> x >> y; try { if (y == 0) { throw -1; } } catch(int ex) { cout 异常可以嵌套，也就是多重异常。 #include using namespace std; int main(int argc, char const *argv[]) { double x, y; cin >> x >> y; try { if (y == 0) { throw -1; } } catch(int ex) { cout "}}